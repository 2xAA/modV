{"version":3,"sources":["webpack:///webpack/bootstrap 78d227b1e763f1e7865d","webpack:///./src/extra/grab-canvas/luminave-connector.js","webpack:///./src/extra/grab-canvas/worker.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kEAAkE;;AAElE;AACA;AACA;AACA,yCAAyC,oBAAoB,EAAE;AAC/D;AACA,KAAK;;AAEL;AACA;AACA,0DAA0D;AAC1D,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA,aAAa,SAAS;AACtB;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,aAAa,SAAS;AAC3C;AACA,0BAA0B,iBAAiB,YAAY;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC,uCAAuC;AACvC,uCAAuC;;AAEvC;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,qBAAqB,OAAO;;AAE/C;AACA,qBAAqB,qBAAqB,OAAO;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAAA;AAAA;;;;;;;;;AC5OA;AAAA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,wCAAwC;;AAErD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"78d227b1e763f1e7865d.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 78d227b1e763f1e7865d","export default class LuminaveConnector {\n  /**\n   * - Create a WebSocket to luminave to transmit colors\n   * - Extract the colors from the modV output canvas (as specified in grab-canvas/index.js)\n   * - Calculate the average color for the whole output and for specified areas\n   *\n   * @param{string} url - WebSocket-URI\n   * @param{number} width - Width of the smallCanvas\n   * @param{number} height - Height of the smallCanvas\n   * @param{number} selectionX - Amount of areas we select on the x-axis\n   * @param{number} selectionY - Amount of areas we select on the y-axis\n   *\n   * @example\n   * Selecting colors:\n   *\n   *\n     selectionX = 4\n     selectionY = 4\n     -----------------\n     a1   b1   c1   d1\n     a2   b2   c2   d2\n     a3   b3   c3   d3\n     a4   b4   c4   d4\n     -----------------\n     => [a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, d1, d2, d3, d4]\n\n     selectionX = 2\n     selectionY = 2\n     -------\n     a1   b1\n     a2   b2\n     -------\n     => [a1, a2, b1, b2]\n   */\n  constructor(args = {}) {\n    this.url = args.url || 'ws://localhost:3000/modV';\n\n    // Width / Height of canvas\n    this.width = args.width || 0;\n    this.height = args.height || 0;\n\n    // Number of selected areas\n    this.selectionX = args.selectionX || 1;\n    this.selectionY = args.selectionY || 1;\n\n    // The raw canvas data\n    this.data = '';\n\n    // WebSocket connection\n    this.reconnectAfter = 4000;\n    this.connection = undefined;\n    this.timeout = 0;\n    this.shouldReconnect = true;\n  }\n\n  /**\n   * Create a WebSocket to luminave\n   */\n  setupSocket() {\n    // Close an old connection\n    this.closeConnection();\n\n    // Create a new connection\n    this.connection = new WebSocket(this.url);\n\n    // Listen for errors (e.g. could not connect)\n    this.connection.addEventListener('error', (event) => {\n      console.error('lumiaveConnector: WebSocket: Error:', event); //eslint-disable-line\n\n      // Reconnect is allowed\n      if (this.shouldReconnect) {\n        // Reconnect after a specific amount of time\n        this.timeout = setTimeout(() => { this.setupSocket(); }, this.reconnectAfter);\n      }\n    });\n\n    // Connection is opened\n    this.connection.addEventListener('open', () => {\n      console.info('lumiaveConnector: WebSocket: Opened'); //eslint-disable-line\n    });\n  }\n\n  /**\n   * Close the WebSocket connection and stop reconnecting\n   */\n  closeConnection() {\n    clearTimeout(this.timeout);\n\n    if (this.connection !== undefined) {\n      this.connection.close();\n    }\n\n    this.connection = undefined;\n  }\n\n  /**\n   * Stop reconnecting to WebSocket\n   */\n  stopReconnect() {\n    this.shouldReconnect = false;\n    clearTimeout(this.timeout);\n  }\n\n  /**\n   * Enable reconnecting to WebSocket\n   */\n  startReconnect() {\n    this.shouldReconnect = true;\n  }\n\n  /**\n   * Send data to WebSocket if connection is established\n   * @param {Array} data \n   */\n  send(data) {\n    // Connection is established\n    if (this.connection !== undefined && this.connection.readyState === 1) {\n      // Send JSON message to luminave\n      this.connection.send(JSON.stringify(data));\n    }\n  }\n\n  /**\n   * Extract the selected areas from the provided canvas data\n   * and send them over WebSocket to luminave.\n   *\n   * @param{Uint8ClampedArray} data - Raw pixel data from canvas\n   */\n  drawFrame(data) {\n    // Data from canvas\n    this.data = new Uint8Array(data);\n\n    // Get the average color of the whole output\n    const average = this.getAverage(0, 0, this.width, this.height);\n\n    // Get the average colors for each area based on selectionX + selectionY\n    const colors = this.getAverageColors();\n\n    // Create the message for luminave\n    const dmxData = {\n      _type: 'modV',\n\n      // Average color of all colors\n      average,\n\n      // Specific colors grabbed from canvas\n      colors,\n    };\n\n    this.send(dmxData);\n  }\n\n  /**\n   * Get the color a the specified coordinates x and y\n   * from the data Uint8ClampedArray.\n   *\n   * @param{number} x - The x position of the color\n   * @param{number} y - The y position of the color\n   *\n   * @return{number[]} red, green, blue at the specified position\n   */\n  getColor(x, y) {\n    const start = y * (this.width * 4) + x * 4; //eslint-disable-line\n\n    // [red, green, blue]\n    return [this.data[start], this.data[start + 1], this.data[start + 2]];\n  }\n\n  /**\n   * Get the average color of the specified \"area\"\n   *\n   * @param{number} x - The x position of the area (top)\n   * @param{number} y - The y position of the area (left)\n   * @param{number} width - The width of the area\n   * @param{number} height - The height of the area\n   *\n   * @return{number[]} red, green, blue for the area\n   */\n  getAverage(x, y, width, height) {\n    const average = new Array(3).fill(0);\n    let color = new Array(3).fill(0);\n    const size = width * height;\n\n    for (let row = 0; row < width; row++) { //eslint-disable-line\n      // For every column pixels\n      for (let column = 0; column < height; column++) { //eslint-disable-line\n        color = this.getColor(x + row, y + column);\n\n        // Summarize the colors\n        average[0] += color[0];\n        average[1] += color[1];\n        average[2] += color[2];\n      }\n    }\n\n    // Calculate the average value\n    average[0] = ~~(average[0] / size); //eslint-disable-line\n    average[1] = ~~(average[1] / size); //eslint-disable-line\n    average[2] = ~~(average[2] / size); //eslint-disable-line\n\n    return average;\n  }\n\n  /**\n   * Get the average colors for all areas.\n   *\n   * @return{number[]} red, green, blue, red, green, blue...\n   */\n  getAverageColors() {\n    // Amount of areas\n    const areaAmount = this.selectionX * this.selectionY;\n\n    // Size of each area\n    const areaSize = (this.width / areaAmount) + (this.height / areaAmount);\n\n    // The packet that gets send over WebSocket to luminave\n    const colors = [];\n\n    // selectionX = how many areas we grab on the x axis\n    for (let x = 0; x < this.selectionX; x++) { //eslint-disable-line\n\n      // selectionY = how many areas we grab on the y axis\n      for (let y = 0; y < this.selectionY; y++) { //eslint-disable-line\n\n        // Coordinates of the area\n        const pointX = (x * Math.floor(this.width / this.selectionX));\n        const pointY = (y * Math.floor(this.height / this.selectionY));\n\n        // Add the average color of the area to the colors\n        colors.push(...this.getAverage(pointX, pointY, areaSize / 2, areaSize / 2));\n      }\n    }\n\n    return colors;\n  }\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/extra/grab-canvas/luminave-connector.js\n// module id = 0\n// module chunks = 0","/* eslint-env worker */\n\nimport LuminaveConnector from './luminave-connector';\n\n// Connect to the luminave-modV integration\n// @see https://github.com/NERDDISCO/luminave#integrations\nconst luminaveConnector = new LuminaveConnector();\n\n/**\n * When the worker receives a message, it triggers different functions\n */\nonmessage = (e) => {\n  const message = e.data;\n\n  switch (message.type) {\n    // Update the settings of LuminaveConnector\n    default: {\n      break;\n    }\n\n    case 'setupCanvas': {\n      const { width, height, selectionX, selectionY } = message.payload;\n\n      luminaveConnector.width = width;\n      luminaveConnector.height = height;\n      luminaveConnector.selectionX = selectionX;\n      luminaveConnector.selectionY = selectionY;\n      break;\n    }\n\n    // Create a WebSocket onnection\n    case 'setupConnection': {\n      const { url, active } = message.payload;\n\n      luminaveConnector.url = url;\n\n      // The plugin is active\n      if (active) {\n        // Stop an old reconnect\n        luminaveConnector.stopReconnect();\n        // Allow reconnects\n        luminaveConnector.startReconnect();\n        // Create the connection\n        luminaveConnector.setupSocket();\n      } else {\n        // Stop an old reconnect because the plugin is not active\n        luminaveConnector.stopReconnect();\n      }\n      \n      break;\n    }\n\n    // Start a connection that will also reconnect\n    case 'startConnection': {\n      luminaveConnector.startReconnect();\n      luminaveConnector.setupSocket();\n      break;\n    }\n\n    // Stop a connection and don't allow reconnect\n    case 'closeConnection': {\n      luminaveConnector.stopReconnect();\n      luminaveConnector.closeConnection();\n      break;\n    }\n\n    // Send the raw pixel data from the modV output canvas to LuminaveConnector\n    case 'data': {\n      luminaveConnector.drawFrame(message.payload);\n      break;\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/eslint-loader?{}!./src/extra/grab-canvas/worker.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}