webpackJsonp([65],{793:function(t,n){t.exports='/*{\n\t"CREDIT": "by mojovideotech",\n  "CATEGORIES" : [\n    "3d",\n    "raymarch",\n    "distortion",\n    "architecture",\n    "twist"\n  ],\n  "DESCRIPTION" : "mod of https:\\/\\/www.shadertoy.com\\/view\\/XltXWN by s23b",\n  "INPUTS" : [\n\t{\n\t\t"NAME": \t"rate",\n\t\t"TYPE": \t"float",\n\t\t"DEFAULT": \t0.0,\n\t\t"MIN": \t\t-1.0,\n\t\t"MAX": \t\t1.0\n\t},\n\t{\n\t\t"NAME": \t"FOV",\n\t\t"TYPE": \t"float",\n\t\t"DEFAULT":\t1.25,\n\t\t"MIN": \t\t-2.5,\n\t\t"MAX": \t\t2.5\n\t},\n\t{\n\t\t"NAME": \t"twist",\n\t\t"TYPE": \t"float",\n\t\t"DEFAULT": \t0.0,\n\t\t"MIN": \t\t-1.0,\n\t\t"MAX": \t\t1.0\n\t},\n\t{\n\t\t"NAME": \t"ambient",\n\t\t"TYPE": \t"float",\n\t\t"DEFAULT": \t0.1,\n\t\t"MIN": \t\t0.0,\n\t\t"MAX": \t\t1.0\n\t},\n    {\n     \t"NAME" :\t"gamma",\n      \t"TYPE" :\t"float",\n      \t"DEFAULT" :\t1.5,\n      \t"MIN" : \t0.5,\n      \t"MAX" :\t\t3.0\t\n\t},\n\t{\n     \t"NAME" :\t"fog",\n      \t"TYPE" :\t"float",\n      \t"DEFAULT" :\t0.025,\n      \t"MIN" : \t0.0025,\n      \t"MAX" :\t\t0.05\n\t}\n  ]\n}\n*/\n\n////////////////////////////////////////////////////////////\n// CollapsingArchitecture  by mojovideotech\n// \n// mod of shadertoy.com\\/XltXWN  by s23b\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////\n\n#define MAX_STEPS 80\n#define EPS .0001\n#define RENDER_DIST 16.\n#define AO_SAMPLES 4.\n#define AO_RANGE 10.\n#define \tPI   \t3.141592653589793 \t// pi\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat hash(vec3 uv) {\n  float f = fract(sin(dot(uv ,vec3(.009123898,.00231233, .00532234)))* 111111.5452313);\n    return f;\n}\n\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 5; ++i) {\n        f += noise((uv + 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\nvoid tTwist(inout vec3 p, float a) {\n    tRotate(p.xy, p.z * a);\n}\n\nfloat tRepeat1(inout float p, float r) {\n    float id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\nvec2 tRepeat2(inout vec2 p, vec2 r) {\n    vec2 id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\nfloat sdRect(vec2 p, vec2 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, p.y), 0.) + length(max(p, 0.));\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\nfloat map(vec3 p) {\n    tTwist(p, twist);\n    tRepeat2(p.xz, vec2(.7, 1.));\n    p.x = abs(p.x);\n    p.y += .5;\n    float d = abs(p.z) - .15 + abs(twist*0.1);\n    float w = opU(sdCircle(p.xy - vec2(0, .75), .25), sdRect(p.xy - vec2(0, .375), vec2(.15, .375)));\n    d = opS(d, w);\n    d = opS(d, sdRect(p.xy - vec2(0,.35), vec2(.45,.3)));\n    d = opU(d, sdCircle(p.xz - vec2(.35, 0.), .067));\n    p.z = abs(p.z);\n    d = opS(d, sdRect(p.yz - vec2(.5, .5), vec2(.6,.4 )));\n    d = opU(d, -abs(p.y - .5) + .8);\n    return d;\n}\n\nfloat trace(vec3 ro, vec3 rd, float maxDist, out float steps) {\n    float total = 0.;\n    steps = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        ++steps;\n        float d = map(ro + rd * total);\n        total += d;\n        if (d < EPS || maxDist < total) break;\n    }\n    return total;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\nfloat calculateAO(vec3 p, vec3 n) {\n    float r = 0., w = 1., d;\n    for (float i = 1.; i <= AO_SAMPLES; i++){\n        d = i / AO_SAMPLES / AO_RANGE;\n        r += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    return 1.-saturate(r * AO_RANGE);\n}\n\nbool isWall(vec3 p) {\n    p.x += .35;\n    tRepeat2(p.xz, vec2(.7, 1));\n    return .375 < abs(p.y + .15) + length(p.xz);\n}\n\nvec3 texture(vec3 p) {\n    vec3 t;\n    tTwist(p, twist);\n    bool wall = isWall(p);\n    t = fbm((p + (wall ? 0. : .1 + .9 * fbm(p * 5.))) * vec3(5., 20., 5.)) * vec3(1., .7, .4) * .75\n        + fbm(p * vec3(2., 10., 2.)) * vec3(1., .8, .5) * .25;\n    if (wall) t = mix(t, vec3(1), .5);\n    return saturate(t);\n}\n\nvoid main() {\n\tvec2 uv = gl_FragCoord.xy / RENDERSIZE.xy * 2. - 1.;\n    uv.x *= RENDERSIZE.x / RENDERSIZE.y;\n    float time = TIME * rate;\n    vec3 ro = vec3(sin(time * PI / 2. + 1.) * 1., 0, time);\n    vec3 rd = normalize(vec3(uv, FOV));\n    time += 2.;\n    vec3 light = vec3(sin(time * PI / 2. + 1.) * 1., 0, time);\n    time -= 2.;\n    tRotate(rd.xz, -cos(time * PI / 2. + 1.) * .5);\n    tRotate(ro.xy, -ro.z * twist);\n    tRotate(light.xy, -light.z * twist);\n    tRotate(rd.xy, -ro.z * twist);\n    float steps, dist = trace(ro, rd, RENDER_DIST, steps); \n    vec3 p = ro + rd * dist;\n    vec3 normal = getNormal(p);\n    vec3 l = normalize(light - p);\n    vec3 shadowStart = p + normal * EPS * 10.;\n    float shadowDistance = distance(shadowStart,light);\n    float shadowSteps, shadow = float(trace(shadowStart, l, shadowDistance, shadowSteps) > shadowDistance);\n    shadow *= 1. - sqrt(shadowSteps / float(MAX_STEPS));\n    float diffuse = max(0., dot(l, normal));\n    float specular = pow(max(0., dot(reflect(-l, normal), -rd)), 8.);\n    float ao = calculateAO(p, normal);        \n    gl_FragColor.rgb = (ao * texture(p)) * (ambient + (specular + diffuse) * shadow);\n    gl_FragColor = mix(gl_FragColor, vec4(.6, .5, .7, 1.), saturate(dist * dist * fog ));\n    gl_FragColor = pow(gl_FragColor, vec4(1. / gamma));\n    gl_FragColor.a = 1.0;\n}\n\n'}});