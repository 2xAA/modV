webpackJsonp([39],{832:function(t,n){t.exports='/*{\n  "CREDIT": "by VIDVOX",\n  "CATEGORIES": [\n    "Generator"\n  ],\n  "INPUTS": [\n    {\n      "NAME": "pointCount",\n      "LABEL": "Point Count",\n      "TYPE": "float",\n      "MIN": 3,\n      "MAX": 90,\n      "DEFAULT": 15\n    },\n    {\n      "NAME": "randomSeed",\n      "LABEL": "Random Seed",\n      "TYPE": "float",\n      "MIN": 0.01,\n      "MAX": 1,\n      "DEFAULT": 0.125\n    },\n    {\n      "NAME": "wobbleAmount",\n      "LABEL": "Wobble Amount",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 0.25,\n      "DEFAULT": 0\n    },\n    {\n      "NAME": "zoomStart",\n      "LABEL": "Zoom Start",\n      "TYPE": "float",\n      "MIN": 0.001,\n      "MAX": 4,\n      "DEFAULT": 0.75\n    },\n    {\n      "NAME": "zoomEnd",\n      "LABEL": "Zoom End",\n      "TYPE": "float",\n      "MIN": 0.001,\n      "MAX": 4,\n      "DEFAULT": 1\n    },\n    {\n      "NAME": "rotationStart",\n      "LABEL": "Winding Start",\n      "TYPE": "float",\n      "MIN": -4,\n      "MAX": 4,\n      "DEFAULT": 0\n    },\n    {\n      "NAME": "rotationEnd",\n      "LABEL": "Winding End",\n      "TYPE": "float",\n      "MIN": -4,\n      "MAX": 4,\n      "DEFAULT": 0\n    },\n    {\n      "NAME": "colorSaturation",\n      "LABEL": "Saturation",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 1,\n      "DEFAULT": 1\n    },\n    {\n      "NAME": "hueBase",\n      "LABEL": "Hue Base",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 1,\n      "DEFAULT": 0.2\n    },\n    {\n      "NAME": "hueRange",\n      "LABEL": "Hue Range",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 1,\n      "DEFAULT": 0.2\n    },\n    {\n      "NAME": "offsetEnd",\n      "TYPE": "point2D",\n      "DEFAULT": [\n        0.5,\n        0.5\n      ]\n    },\n    {\n      "NAME": "randomizeBrightness",\n      "LABEL": "Randomize Brightness",\n      "TYPE": "bool",\n      "DEFAULT": true\n    },\n    {\n      "NAME": "randomizeAlpha",\n      "LABEL": "Randomize Alpha",\n      "TYPE": "bool",\n      "DEFAULT": false\n    },\n    {\n      "NAME": "randomizeAllPoints",\n      "LABEL": "Randomize Points",\n      "TYPE": "bool",\n      "DEFAULT": false\n    }\n  ]\n}*/\n\n\n\nconst float pi = 3.14159265359;\n\n\n\nvec2 rotatePoint(vec2 pt, float angle, vec2 center)\n{\n\tvec2 returnMe;\n\tfloat s = sin(angle * pi);\n\tfloat c = cos(angle * pi);\n\n\treturnMe = pt;\n\n\t// translate point back to origin:\n\treturnMe.x -= center.x;\n\treturnMe.y -= center.y;\n\n\t// rotate point\n\tfloat xnew = returnMe.x * c - returnMe.y * s;\n\tfloat ynew = returnMe.x * s + returnMe.y * c;\n\n\t// translate point back:\n\treturnMe.x = xnew + center.x;\n\treturnMe.y = ynew + center.y;\n\treturn returnMe;\n}\n\n\nvec3 rgb2hsv(vec3 c)\t{\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\t//vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\t//vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\t\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\t{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat sign(vec2 p1, vec2 p2, vec2 p3)\t{\n\treturn (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool PointInTriangle(vec2 pt, vec2 v1, vec2 v2, vec2 v3)\t{\n\tbool b1, b2, b3;\n\n\tb1 = sign(pt, v1, v2) < 0.0;\n\tb2 = sign(pt, v2, v3) < 0.0;\n\tb3 = sign(pt, v3, v1) < 0.0;\n\n\treturn ((b1 == b2) && (b2 == b3));\n}\n\n\nvoid main() {\n\tvec4\t\tresult = vec4(0.0);\n\tvec2\t\tthisPoint = gl_FragCoord.xy;\n\tvec3\t\tcolorHSL;\n\tvec2\t\tpt1, pt2, pt3;\n\tvec2\t\toffsetIncrement = (4.0 * (offsetEnd / RENDERSIZE - vec2(0.5)) / (pointCount - 2.0));\n\tfloat\t\trotationIncrement = (rotationEnd - rotationStart) / pointCount;\n\tfloat\t\tzoomIncrement = (zoomEnd - zoomStart) / pointCount;\n\t\n\tthisPoint = rotatePoint(thisPoint, rotationStart, RENDERSIZE/2.0);\n\tthisPoint = thisPoint / RENDERSIZE;\n\tthisPoint = (thisPoint - vec2(0.5)) / zoomStart + vec2(0.5);\n\t\n\tcolorHSL.x = hueBase;\n\tcolorHSL.y = colorSaturation;\n\tcolorHSL.z = 1.0;\n\tif (randomizeBrightness)\t{\n\t\tcolorHSL.z = rand(vec2(floor(pointCount)+randomSeed * 3.72, randomSeed + pointCount * 0.649));\n\t}\n\t\n\tvec2 wobbleVector = vec2(0.0);\n\t\n\tpt1 = vec2(rand(vec2(floor(pointCount)+randomSeed*1.123,randomSeed*1.321)),rand(vec2(randomSeed*2.123,randomSeed*3.325)));\n\tpt2 = vec2(rand(vec2(floor(pointCount)+randomSeed*5.317,randomSeed*2.591)),rand(vec2(randomSeed*1.833,randomSeed*4.916)));\n\tpt3 = vec2(rand(vec2(floor(pointCount)+randomSeed*3.573,randomSeed*6.273)),rand(vec2(randomSeed*9.253,randomSeed*7.782)));\n\t\n\tif (wobbleAmount > 0.0)\t{\n\t\twobbleVector = wobbleAmount * vec2(rand(vec2(TIME*1.123,TIME*3.239)),rand(vec2(TIME*3.321,TIME*2.131))) - vec2(wobbleAmount / 2.0);\n\t\tpt1 = pt1 + wobbleVector;\n\t\t\n\t\twobbleVector = wobbleAmount * vec2(rand(vec2(TIME*6.423,TIME*1.833)),rand(vec2(TIME*2.436,TIME*7.532))) - vec2(wobbleAmount / 2.0);\n\t\tpt2 = pt2 + wobbleVector;\n\t\t\n\t\twobbleVector = wobbleAmount * vec2(rand(vec2(TIME*3.951,TIME*3.538)),rand(vec2(TIME*8.513,TIME*6.335))) - vec2(wobbleAmount / 2.0);\n\t\tpt3 = pt3 + wobbleVector;\n\t}\n\t\n\tif (PointInTriangle(thisPoint,pt1,pt2,pt3))\t{\n\t\tfloat newAlpha = 1.0;\n\t\t\n\t\tif (randomizeAlpha)\t{\n\t\t\tnewAlpha = 0.5 + 0.5 * rand(vec2(1.0 + floor(pointCount)+randomSeed * 1.938, randomSeed * pointCount * 1.541));\n\t\t}\n\t\t\n\t\tresult.rgb = hsv2rgb(colorHSL);\n\t\tresult.a = result.a + newAlpha;\n\t}\n\t\n\tfor (float i = 0.0; i < 90.0; ++i)\t{\n\t\tif (result.a > 0.75)\n\t\t\tbreak;\n\t\tif (i > pointCount - 3.0)\n\t\t\tbreak;\n\t\tif (randomizeAllPoints)\t{\n\t\t\tpt1 = vec2(rand(vec2(i+randomSeed*1.123,i*floor(pointCount)+randomSeed*1.321)),rand(vec2(i*floor(pointCount)+randomSeed*2.123,i+randomSeed*1.325)));\n\t\t\tpt2 = vec2(rand(vec2(i*floor(pointCount)+randomSeed*5.317,randomSeed*2.591)),rand(vec2(i+randomSeed*1.833,i*floor(pointCount)+randomSeed*4.916)));\n\t\t\t\n\t\t\tif (wobbleAmount > 0.0)\t{\n\t\t\t\twobbleVector = wobbleAmount * vec2(rand(vec2(i*floor(pointCount)+TIME*3.123,i*floor(pointCount)+TIME*3.239)),rand(vec2(i*floor(pointCount)+TIME*3.321,i*floor(pointCount)+TIME*2.131))) - vec2(wobbleAmount / 2.0);\n\t\t\t\tpt1 = pt1 + wobbleVector;\n\t\t\t\n\t\t\t\twobbleVector = wobbleAmount * vec2(rand(vec2(i*floor(pointCount)+TIME*6.423,i*floor(pointCount)+TIME*1.833)),rand(vec2(i*floor(pointCount)+TIME*2.436,i*floor(pointCount)+TIME*7.532))) - vec2(wobbleAmount / 2.0);\n\t\t\t\tpt2 = pt2 + wobbleVector;\n\t\t\t}\n\t\t}\n\t\telse\t{\n\t\t\tpt1 = pt2;\n\t\t\tpt2 = pt3;\n\t\t}\n\t\tpt3 = vec2(rand(vec2(i*floor(pointCount)+randomSeed*3.573,i+randomSeed*6.273)),rand(vec2(i+randomSeed*9.253,i+randomSeed*7.782)));\n\t\tpt3 = (pt3 - vec2(0.5)) * (zoomStart + zoomIncrement * i) + vec2(0.5);\n\t\tpt3 = rotatePoint(pt3, rotationStart + rotationIncrement * i, vec2(0.5));\n\t\tpt3 = pt3 + offsetIncrement * i;\n\t\t\n\t\tif (wobbleAmount > 0.0)\t{\n\t\t\twobbleVector = wobbleAmount * vec2(rand(vec2(i*floor(pointCount)+TIME*3.573,i+randomSeed*6.273)),rand(vec2(i+TIME*9.253,i+TIME*7.782))) - vec2(wobbleAmount / 2.0);\n\t\t\tpt3 = pt3 + wobbleVector;\n\t\t}\n\t\t\n\t\tif (PointInTriangle(thisPoint,pt1,pt2,pt3))\t{\n\t\t\t//result = vec4(1.0);\n\t\t\tfloat newAlpha = 1.0;\n\t\t\t\n\t\t\tif (randomizeAlpha)\t{\n\t\t\t\tnewAlpha = 0.1 + 0.25 * rand(vec2(i + floor(pointCount)+randomSeed * 1.938, randomSeed * pointCount * 1.541));\n\t\t\t}\n\t\t\t\n\t\t\tcolorHSL.x = mod(hueBase + hueRange * rand(vec2(floor(pointCount)+randomSeed, i)), 1.0);\n\t\t\tif (randomizeBrightness)\t{\n\t\t\t\tcolorHSL.z = 0.25 + 0.85 * rand(vec2(i + floor(pointCount)+randomSeed * 2.78, randomSeed + pointCount * 0.249));\n\t\t\t}\n\t\t\tresult.rgb = result.rgb + hsv2rgb(colorHSL) * newAlpha;\n\t\t\tresult.a = result.a + newAlpha;\n\t\t}\n\t}\n\t\n\tgl_FragColor = result;\n}'}});