webpackJsonp([0,46,47],{782:function(t,e){t.exports='/*{\n  "DESCRIPTION": "Uses an optical flow mask to create a distortion",\n  "CREDIT": "by VIDVOX, based on original implementation by Andrew Benson and v002",\n  "CATEGORIES": [\n    "Distortion Effect"\n  ],\n  "INPUTS": [\n    {\n      "NAME": "inputImage",\n      "TYPE": "image"\n    },\n    {\n      "NAME": "amt",\n      "LABEL": "Distortion Amount",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 1,\n      "DEFAULT": 0.5\n    },\n    {\n      "NAME": "maskHold",\n      "LABEL": "Flow Persistence",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 1,\n      "DEFAULT": 0.98\n    },\n    {\n      "NAME": "inputScale",\n      "LABEL": "Scale",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 10,\n      "DEFAULT": 2\n    },\n    {\n      "NAME": "inputOffset",\n      "LABEL": "Offset",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 1,\n      "DEFAULT": 0.1\n    },\n    {\n      "NAME": "inputLambda",\n      "LABEL": "Noise Removal",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 1,\n      "DEFAULT": 1\n    }\n  ],\n  "PASSES": [\n    {\n      "TARGET": "maskBuffer",\n      "persistent": true\n    },\n    {\n      "TARGET": "delayBuffer",\n      "persistent": true\n    },\n    {}\n  ]\n}*/\n\n\nvarying vec2 left_coord;\nvarying vec2 right_coord;\nvarying vec2 above_coord;\nvarying vec2 below_coord;\n\nvarying vec2 lefta_coord;\nvarying vec2 righta_coord;\nvarying vec2 leftb_coord;\nvarying vec2 rightb_coord;\n\n\n//\tbased on v002 Optical Flow which is itself a port of Andrew Bensons HS Flow implementation on the GPU.\n//\thttps://github.com/v002/v002-Optical-Flow\n\n\nconst vec4 coeffs = vec4(0.2126, 0.7152, 0.0722, 1.0);\n\nfloat gray(vec4 n)\n{\n\treturn (n.r + n.g + n.b)/3.0;\n}\n\nvoid main()\n{\n\t//\ton the first pass generate the mask using the previous delayBuffer and inputImage\n\t//\ton the 2nd pass update the delayBuffer to hold inputImage\n\t//\ton the 3rd pass output the new mask\n\tif (PASSINDEX == 0)\t{\n\t\t//\tconvert to grayscale\n\t\tvec4 a = IMG_THIS_PIXEL(inputImage) * coeffs;\n\t\tfloat brightness = gray(a);\n\t\ta = vec4(brightness);\n\t\tvec4 b = IMG_THIS_PIXEL(delayBuffer) * coeffs;\n\t\tbrightness = gray(b);\n\t\tb = vec4(brightness);\n\t\t\n\t\tvec2 x1 = vec2(inputOffset * RENDERSIZE.x, 0.0);\n\t\tvec2 y1 = vec2(0.0,inputOffset * RENDERSIZE.y);\n\t\tvec2 texcoord0 = isf_FragNormCoord.xy * RENDERSIZE;\n\t\tvec2 texcoord1 = isf_FragNormCoord.xy * RENDERSIZE;\n\t\t\n\t\t//get the difference\n\t\tvec4 curdif = b-a;\n\t\n\t\t//calculate the gradient\n\t\tvec4 gradx = IMG_PIXEL(delayBuffer, texcoord1+x1)-IMG_PIXEL(delayBuffer, texcoord1-x1);\n\t\tgradx += IMG_PIXEL(inputImage, texcoord0+x1)-IMG_PIXEL(inputImage, texcoord0-x1);\n\t\n\t\tvec4 grady = IMG_PIXEL(delayBuffer, texcoord1+y1)-IMG_PIXEL(delayBuffer, texcoord1-y1);\n\t\tgrady += IMG_PIXEL(inputImage, texcoord0+y1)-IMG_PIXEL(inputImage, texcoord0-y1);\n\t\n\t\tvec4 gradmag = sqrt((gradx*gradx)+(grady*grady)+vec4(inputLambda));\n\n\t\tvec4 vx = curdif*(gradx/gradmag);\n\t\tfloat vxd = gray(vx);//assumes greyscale\n\t\t//format output for flowrepos, out(-x,+x,-y,+y)\n\t\tvec2 xout = vec2(max(vxd,0.),abs(min(vxd,0.)))*inputScale;\n\n\t\tvec4 vy = curdif*(grady/gradmag);\n\t\tfloat vyd = gray(vy);//assumes greyscale\n\t\t//format output for flowrepos, out(-x,+x,-y,+y)\n\t\tvec2 yout = vec2(max(vyd,0.),abs(min(vyd,0.)))*inputScale;\n\t\n\t\tvec4 mask = clamp(vec4(xout.xy,yout.xy), 0.0, 1.0);\n\t\t\n\t\tvec4 color = IMG_THIS_NORM_PIXEL(maskBuffer);\n\t\tvec4 colorL = IMG_NORM_PIXEL(maskBuffer, left_coord);\n\t\tvec4 colorR = IMG_NORM_PIXEL(maskBuffer, right_coord);\n\t\tvec4 colorA = IMG_NORM_PIXEL(maskBuffer, above_coord);\n\t\tvec4 colorB = IMG_NORM_PIXEL(maskBuffer, below_coord);\n\n\t\tvec4 colorLA = IMG_NORM_PIXEL(maskBuffer, lefta_coord);\n\t\tvec4 colorRA = IMG_NORM_PIXEL(maskBuffer, righta_coord);\n\t\tvec4 colorLB = IMG_NORM_PIXEL(maskBuffer, leftb_coord);\n\t\tvec4 colorRB = IMG_NORM_PIXEL(maskBuffer, rightb_coord);\n\n\t\t//\tblur the feedback buffer\n\t\tvec4 blurVector = (color + colorL + colorR + colorA + colorB + colorLA + colorRA + colorLB + colorRB) / 9.0;\n\t\tgl_FragColor = mask + maskHold * blurVector;\n\t}\n\telse if (PASSINDEX == 1)\t{\t\n\t\t//\there we just buffer the current frame for next time\n\t\tgl_FragColor = IMG_THIS_PIXEL(inputImage);\n\t}\n\telse\t{\n\t\t//\tNOW DO SOMETHING WITH THE MASK - BLUR THE IMAGE AND THE MASK IMAGE\n\t\t\n\t\t//\tblur the mask image\n\t\tvec2 texcoord0 = isf_FragNormCoord.xy;\n\t\t\n\t\tvec4 color = IMG_THIS_NORM_PIXEL(maskBuffer);\n\t\tvec4 colorL = IMG_NORM_PIXEL(maskBuffer, left_coord);\n\t\tvec4 colorR = IMG_NORM_PIXEL(maskBuffer, right_coord);\n\t\tvec4 colorA = IMG_NORM_PIXEL(maskBuffer, above_coord);\n\t\tvec4 colorB = IMG_NORM_PIXEL(maskBuffer, below_coord);\n\n\t\tvec4 colorLA = IMG_NORM_PIXEL(maskBuffer, lefta_coord);\n\t\tvec4 colorRA = IMG_NORM_PIXEL(maskBuffer, righta_coord);\n\t\tvec4 colorLB = IMG_NORM_PIXEL(maskBuffer, leftb_coord);\n\t\tvec4 colorRB = IMG_NORM_PIXEL(maskBuffer, rightb_coord);\n\t\t\n\t\tvec4 blurVector = (color + colorL + colorR + colorA + colorB + colorLA + colorRA + colorLB + colorRB) / 9.0;\n\t\t//vec4 blurVector = IMG_THIS_PIXEL(maskBuffer);\n\t\t\n\t\tvec2 blurAmount = vec2(blurVector.y-blurVector.x, blurVector.w-blurVector.z);\n\t\tvec2 tmp = texcoord0 + blurAmount * amt;\n\t\ttmp.x = clamp(tmp.x,0.0,1.0);\n\t\ttmp.y = clamp(tmp.y,0.0,1.0);\n\t\tvec4 sample0 = IMG_NORM_PIXEL(inputImage, tmp);\n\t\ttmp = (1.02 + texcoord0) + blurAmount * amt * amt;\n\t\ttmp.x = clamp(tmp.x,0.0,1.0);\n\t\ttmp.y = clamp(tmp.y,0.0,1.0);\n\t\tvec4 sample1 = IMG_NORM_PIXEL(inputImage, tmp);\n\t\tgl_FragColor = (sample0 * 3.0 + sample1) / 4.0;\n\t}\n}\n'},783:function(t,e){t.exports="varying vec2 left_coord;\nvarying vec2 right_coord;\nvarying vec2 above_coord;\nvarying vec2 below_coord;\n\nvarying vec2 lefta_coord;\nvarying vec2 righta_coord;\nvarying vec2 leftb_coord;\nvarying vec2 rightb_coord;\n\n\nvoid main()\n{\n\tisf_vertShaderInit();\n\tvec2 texc = vec2(isf_FragNormCoord[0],isf_FragNormCoord[1]);\n\tvec2 d = 4.0/RENDERSIZE;\n\n\tleft_coord = clamp(vec2(texc.xy + vec2(-d.x , 0)),0.0,1.0);\n\tright_coord = clamp(vec2(texc.xy + vec2(d.x , 0)),0.0,1.0);\n\tabove_coord = clamp(vec2(texc.xy + vec2(0,d.y)),0.0,1.0);\n\tbelow_coord = clamp(vec2(texc.xy + vec2(0,-d.y)),0.0,1.0);\n\n\tlefta_coord = clamp(vec2(texc.xy + vec2(-d.x , d.x)),0.0,1.0);\n\trighta_coord = clamp(vec2(texc.xy + vec2(d.x , d.x)),0.0,1.0);\n\tleftb_coord = clamp(vec2(texc.xy + vec2(-d.x , -d.x)),0.0,1.0);\n\trightb_coord = clamp(vec2(texc.xy + vec2(d.x , -d.x)),0.0,1.0);\n}"},796:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(783),r=n.n(o),c=n(782),a=n.n(c);e.default={meta:{name:"Optical Flow Distort",author:"2xAA",version:"1.0.0",type:"isf"},fragmentShader:a.a,vertexShader:r.a}}});