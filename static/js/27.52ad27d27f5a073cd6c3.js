webpackJsonp([27],{844:function(n,e){n.exports='/*\n{\n  "CATEGORIES" : [\n    "bokeh",\n    "blur"\n  ],\n  "INPUTS" : [\n    {\n      "NAME" : "inputImage",\n      "TYPE" : "image"\n    },\n    {\n      "NAME" : "mX",\n      "TYPE" : "float",\n      "MAX" : 1,\n      "DEFAULT" : 0.5,\n      "LABEL" : "Mouse X",\n      "MIN" : 0\n    },\n    {\n      "NAME" : "mY",\n      "TYPE" : "float",\n      "MAX" : 1,\n      "DEFAULT" : 0.5,\n      "LABEL" : "Mouse Y",\n      "MIN" : 0\n    },\n    {\n      "NAME" : "mZ",\n      "TYPE" : "float",\n      "MAX" : 1,\n      "DEFAULT" : 0.5,\n      "LABEL" : "Mouse Z",\n      "MIN" : 0\n    },\n    {\n      "NAME" : "mW",\n      "TYPE" : "float",\n      "MAX" : 1,\n      "DEFAULT" : 0.5,\n      "LABEL" : "Mouse W",\n      "MIN" : 0\n    }\n  ],\n  "PASSES" : [\n    {\n      "TARGET" : "buffer1"\n    },\n    {\n      "TARGET" : "buffer2"\n    }\n  ],\n  "ISFVSN" : "2",\n  "CREDIT" : "hornet"\n}\n*/\n\nvec3 iResolution = vec3(RENDERSIZE, 1.);\nvec4 iMouse = vec4(mX*RENDERSIZE.x, mY*RENDERSIZE.y, mZ*RENDERSIZE.x, mW*RENDERSIZE.y);\n\n#define USE_RANDOM\n\nconst float blurdist_px = 64.0;\nconst int NUM_SAMPLES = 16;\n\nconst float THRESHOLD = 0.1;\nconst float MULT = 4.0;\n\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n\n//note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n  p  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n  return fract(p.x * p.y * 95.4307);\n}\n\nvec4 pattern( vec2 p )\n{\n    float aspect = iResolution.x / iResolution.y;\n    float p0 = step(abs(p.x-0.125), 0.01) * step(abs(p.y-0.27), 0.01);\n    float p1 = step( length( p-vec2(0.125, 0.45) ), 0.025 );\n\n    float p2_0 = step( length( p-vec2(0.08, 0.14) ), 0.0125 );\n    float p2_1 = step( length( p-vec2(0.16, 0.125) ), 0.0125 );\n    float p2_2 = step( length( p-vec2(0.1, 0.07) ), 0.0125 );\n    float p2 = max(p2_0, max(p2_1,p2_2));\n\n    return vec4( max( p0, max(p1,p2) ) );\n}\n\nvec3 sampletex( vec2 uv ) {\n    float t = fract( 0.1 * TIME );\n    return IMG_NORM_PIXEL( buffer1, uv, -10.0 ).rgb;\n}\n\nvoid pass1( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float sinblur = ( 0.55 + 0.45 * sin( 5.0 * uv.x + TIME ) );\n    float blurdist = (iMouse.z>0.5) ? 100.0 * iMouse.x/iResolution.x : blurdist_px * sinblur;\n\n    float srnd = hash12n(uv+fract(TIME))-0.5;\n\n    vec3 sumcol0 = vec3(0.0);\n    {\n        vec2 blurdir = vec2( 1.0, 0.577350269189626 );\n      vec2 blurvec = normalize(blurdir) / iResolution.xy;\n        vec2 p0 = uv - 0.5 * blurdist * blurvec;\n      vec2 p1 = uv + 0.5 * blurdist * blurvec;\n      vec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n      vec2 p = p0;\n        #if defined(USE_RANDOM)\n        p += srnd * stepvec;\n        #endif\n\n        for (int i=0;i<NUM_SAMPLES;++i)\n        {\n          sumcol0 += srgb2lin( IMG_NORM_PIXEL( inputImage, p, -10.0 ).rgb);\n          p += stepvec;\n        }\n        sumcol0 /= float(NUM_SAMPLES);\n    }\n\n    vec3 sumcol1 = vec3(0.0);\n    {\n        vec2 blurdir = vec2( -1.0, 0.577350269189626 );\n        vec2 blurvec = normalize(blurdir) / iResolution.xy;\n        vec2 p0 = uv - 0.5 * blurdist * blurvec;\n        vec2 p1 = uv + 0.5 * blurdist * blurvec;\n        vec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n        vec2 p = p0;\n        #if defined(USE_RANDOM)\n        p += srnd * stepvec;\n        #endif\n\n        for (int i=0;i<NUM_SAMPLES;++i)\n        {\n          sumcol1 += srgb2lin( IMG_NORM_PIXEL( inputImage, p, -10.0 ).rgb);\n          p += stepvec;\n        }\n        sumcol1 /= float(NUM_SAMPLES);\n    }\n\n    //DEBUG\n    //fragColor = vec4( sumcol0, 1.0 ); return;\n    //fragColor = vec4( sumcol1, 1.0 ); return;\n\n    vec3 sumcol = min( sumcol0, sumcol1 );\n\n    fragColor = vec4( lin2srgb(sumcol), 1.0 );\n}\n\nvoid pass2( out vec4 fragColor, in vec2 fragCoord ) {\n    const vec2 blurdir = vec2( 0.0, 1.0 );\n    vec2 blurvec = normalize(blurdir) / iResolution.xx;\n    //fragCoord += 25.0 * vec2( cos(TIME), sin(TIME) );\n    vec2 suv = fragCoord / iResolution.xy;\n    vec2 uv = fragCoord / iResolution.xx;\n    float sinblur = ( 0.55 + 0.45 * sin( 5.0 * uv.x + TIME ) );\n    float blurdist = (iMouse.z>0.5) ? 100.0 * iMouse.x/iResolution.x : blurdist_px * sinblur;\n\n    vec2 p0 = uv - 0.5 * blurdist * blurvec;\n    vec2 p1 = uv + 0.5 * blurdist * blurvec;\n    vec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n    vec2 p = p0;\n    #if defined(USE_RANDOM)\n    p += (hash12n(uv+fract(TIME))-0.5) * stepvec;\n    #endif\n\n    vec3 sumcol = vec3(0.0);\n    for (int i=0;i<NUM_SAMPLES;++i)\n    {\n        //if ( p.x < 0.25 )\n        //    sumcol += pattern( p ).rgb;\n        //else\n        //{\n            vec3 smpl = srgb2lin((sampletex(p) - THRESHOLD) / (1.0-THRESHOLD));\n            sumcol += smpl*smpl; //wtf\n        //}\n        p += stepvec;\n    }\n    sumcol /= float(NUM_SAMPLES);\n    sumcol = max( sumcol, 0.0 );\n\n    fragColor = vec4( lin2srgb( sumcol * MULT ), 1.0 );\n}\n\n\nvoid main(void) {\n  if(PASSINDEX == 0) {\n    pass1(gl_FragColor, gl_FragCoord.xy);\n  } else if(PASSINDEX == 1) {\n    pass2(gl_FragColor, gl_FragCoord.xy);\n  } else {\n    gl_FragColor = IMG_THIS_NORM_PIXEL(buffer2);\n  }\n}'}});