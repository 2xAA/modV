webpackJsonp([37],{815:function(t,r){t.exports='/*{\n  "CREDIT": "by zoidberg",\n  "CATEGORIES": [\n    "Halftone Effect"\n  ],\n  "INPUTS": [\n    {\n      "NAME": "inputImage",\n      "TYPE": "image"\n    },\n    {\n      "NAME": "gridSize",\n      "TYPE": "float",\n      "MIN": 1,\n      "MAX": 256,\n      "DEFAULT": 45\n    },\n    {\n      "NAME": "smoothing",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 1,\n      "DEFAULT": 0.15\n    }\n  ]\n}*/\r\n\r\nvec4\t\tgridRot = vec4(15.0, 45.0, 75.0, 0.0);\r\n//vec4\t\tgridRot = vec4(15.0, 75.0, 0.0, 45.0);\r\n//vec4\t\tgridRot = vec4(0.0, 0.0, 0.0, 0.0);\r\n\r\n\r\n\r\n//\tduring calculation we find the closest dot to a frag, determine its size, and then determine the size of the four dots above/below/right/left of it. this array of offsets move "one left", "one up", "one right", and "one down"...\r\nvec2\t\toriginOffsets[4];\r\n\r\n\r\n\r\nvoid main() {\r\n\t//\ta halftone is an overlapping series of grids of dots\r\n\t//\teach grid of dots is rotated by a different amount\r\n\t//\tthe size of the dots determines the colors. the shape of the dot should never change (always be a dot with regular edges)\r\n\toriginOffsets[0] = vec2(-1.0, 0.0);\r\n\toriginOffsets[1] = vec2(0.0, 1.0);\r\n\toriginOffsets[2] = vec2(1.0, 0.0);\r\n\toriginOffsets[3] = vec2(0.0, -1.0);\r\n\t\r\n\tvec3\t\trgbAmounts = vec3(0.0);\r\n\r\n\t//\tfor each of the channels (i) of RGB...\r\n\tfor (float i=0.0; i<3.0; ++i)\t{\r\n\t\t//\tfigure out the rotation of the grid in radians\r\n\t\tfloat\t\trotRad = radians(gridRot[int(i)]);\r\n\t\t//\tthe grids are rotated counter-clockwise- to find the nearest dot, take the fragment pixel loc, \r\n\t\t//\trotate it clockwise, and split by the grid to find the center of the dot. then rotate this \r\n\t\t//\tcoord counter-clockwise to yield the location of the center of the dot in pixel coords local to the render space\r\n\t\tmat2\t\tccTrans = mat2(vec2(cos(rotRad), sin(rotRad)), vec2(-1.0*sin(rotRad), cos(rotRad)));\r\n\t\tmat2\t\tcTrans = mat2(vec2(cos(rotRad), -1.0*sin(rotRad)), vec2(sin(rotRad), cos(rotRad)));\r\n\t\t\r\n\t\t//\tfind the location of the frag in the grid (prior to rotating it)\r\n\t\tvec2\t\tgridFragLoc = cTrans * gl_FragCoord.xy;\r\n\t\t//\tfind the center of the dot closest to the frag- there\'s no "round" in GLSL 1.2, so do a "floor" to find the dot to the bottom-left of the frag, then figure out if the frag would be in the top and right halves of that square to find the closest dot to the frag\r\n\t\tvec2\t\tgridOriginLoc = vec2(floor(gridFragLoc.x/gridSize), floor(gridFragLoc.y/gridSize));\r\n\t\t\r\n\t\tvec2\t\ttmpGridCoords = gridFragLoc/vec2(gridSize);\r\n\t\tbool\t\tfragAtTopOfGrid = ((tmpGridCoords.y-floor(tmpGridCoords.y)) > (gridSize/2.0)) ? true : false;\r\n\t\tbool\t\tfragAtRightOfGrid = ((tmpGridCoords.x-floor(tmpGridCoords.x)) > (gridSize/2.0)) ? true : false;\r\n\t\tif (fragAtTopOfGrid)\r\n\t\t\tgridOriginLoc.y = gridOriginLoc.y + 1.0;\r\n\t\tif (fragAtRightOfGrid)\r\n\t\t\tgridOriginLoc.x = gridOriginLoc.x + 1.0;\r\n\t\t//\t...at this point, "gridOriginLoc" contains the grid coords of the nearest dot to the fragment being rendered\r\n\t\t//\tconvert the location of the center of the dot from grid coords to pixel coords\r\n\t\tvec2\t\tgridDotLoc = vec2(gridOriginLoc.x*gridSize, gridOriginLoc.y*gridSize) + vec2(gridSize/2.0);\r\n\t\t//\trotate the pixel coords of the center of the dot so they become relative to the rendering space\r\n\t\tvec2\t\trenderDotLoc = ccTrans * gridDotLoc;\r\n\t\t//\tget the color of the pixel of the input image under this dot (the color will ultimately determine the size of the dot)\r\n\t\tvec4\t\trenderDotImageColorRGB = IMG_PIXEL(inputImage, renderDotLoc);\r\n\t\t\r\n\t\t\r\n\t\t//\tthe amount of this channel is taken from the same channel of the color of the pixel of the input image under this halftone dot\r\n\t\tfloat\t\timageChannelAmount = renderDotImageColorRGB[int(i)];\r\n\t\t//\tthe size of the dot is determined by the value of the channel\r\n\t\tfloat\t\tdotRadius = imageChannelAmount * (gridSize*1.50/2.0);\r\n\t\tfloat\t\tfragDistanceToDotCenter = distance(gl_FragCoord.xy, renderDotLoc);\r\n\t\tif (fragDistanceToDotCenter < dotRadius)\t{\r\n\t\t\trgbAmounts[int(i)] += smoothstep(dotRadius, dotRadius-(dotRadius*smoothing), fragDistanceToDotCenter);\r\n\t\t}\r\n\t\t\r\n\t\t//\tcalcluate the size of the dots abov/below/to the left/right to see if they\'re overlapping\r\n\t\tfor (float j=0.0; j<4.0; ++j)\t{\r\n\t\t\tgridDotLoc = vec2((gridOriginLoc.x+originOffsets[int(j)].x)*gridSize, (gridOriginLoc.y+originOffsets[int(j)].y)*gridSize) + vec2(gridSize/2.0);\r\n\t\t\trenderDotLoc = ccTrans * gridDotLoc;\r\n\t\t\trenderDotImageColorRGB = IMG_PIXEL(inputImage, renderDotLoc);\r\n\t\t\t\r\n\t\t\timageChannelAmount = renderDotImageColorRGB[int(i)];\r\n\t\t\tdotRadius = imageChannelAmount * (gridSize*1.50/2.0);\r\n\t\t\tfragDistanceToDotCenter = distance(gl_FragCoord.xy, renderDotLoc);\r\n\t\t\tif (fragDistanceToDotCenter < dotRadius)\t{\r\n\t\t\t\trgbAmounts[int(i)] += smoothstep(dotRadius, dotRadius-(dotRadius*smoothing), fragDistanceToDotCenter);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tgl_FragColor = vec4(rgbAmounts[0], rgbAmounts[1], rgbAmounts[2], 1.0);\r\n}'}});