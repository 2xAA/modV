webpackJsonp([19],{852:function(n,e){n.exports='/*{\n  "DESCRIPTION": "Buffers 8 recent frames",\n  "CREDIT": "by VIDVOX",\n  "CATEGORIES": [\n    "Glitch"\n  ],\n  "INPUTS": [\n    {\n      "NAME": "inputImage",\n      "TYPE": "image"\n    },\n    {\n      "NAME": "inputDelay",\n      "LABEL": "Buffer",\n      "TYPE": "color",\n      "DEFAULT": [\n        0.25,\n        0.5,\n        0.75,\n        0.5\n      ]\n    },\n    {\n      "NAME": "inputRate",\n      "LABEL": "Buffer Lag",\n      "TYPE": "float",\n      "MIN": 1.0,\n      "MAX": 20.0,\n      "DEFAULT": 4.0\n    },\n    {\n      "NAME": "glitch_size",\n      "LABEL": "Size",\n      "TYPE": "float",\n      "MIN": 0.0,\n      "MAX": 0.5,\n      "DEFAULT": 0.1\n    },\n    {\n      "NAME": "glitch_horizontal",\n      "LABEL": "Horizontal Amount",\n      "TYPE": "float",\n      "MIN": 0.0,\n      "MAX": 1.0,\n      "DEFAULT": 0.2\n    },\n    {\n      "NAME": "glitch_vertical",\n      "LABEL": "Vertical Amount",\n      "TYPE": "float",\n      "MIN": 0.0,\n      "MAX": 1.0,\n      "DEFAULT": 0.0\n    },\n    {\n      "NAME": "randomize_size",\n      "LABEL": "Randomize Size",\n      "TYPE": "bool",\n      "DEFAULT": 1.0\n    },\n    {\n      "NAME": "randomize_position",\n      "LABEL": "Randomize Position",\n      "TYPE": "bool",\n      "DEFAULT": 0.0\n    },\n    {\n      "NAME": "randomize_zoom",\n      "LABEL": "Randomize Zoom",\n      "TYPE": "bool",\n      "DEFAULT": 0.0\n    }\n  ],\n  "PERSISTENT_BUFFERS": [\n    "lastRow",\n    "buffer1",\n    "buffer2",\n    "buffer3",\n    "buffer4",\n    "buffer5",\n    "buffer6",\n    "buffer7",\n    "buffer8"\n  ],\n  "PASSES": [\n    {\n      "TARGET":"lastRow",\n      "WIDTH:": 1,\n      "HEIGHT": 1,\n      "DESCRIPTION": "this buffer stores the last frame\'s odd / even state"\n    },\n    {\n      "TARGET":"buffer8"\n    },\n    {\n      "TARGET":"buffer7"\n    },\n    {\n      "TARGET":"buffer6"\n    },\n    {\n      "TARGET":"buffer5"\n    },\n    {\n      "TARGET":"buffer4"\n    },\n    {\n      "TARGET":"buffer3"\n    },\n    {\n      "TARGET":"buffer2"\n    },\n    {\n      "TARGET":"buffer1"\n    },\n    {\n\n    }\n  ]\n\n}*/\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid main()\n{\n  //\tfirst pass: read the "buffer7" into "buffer8"\n  //\tapply lag on each pass\n  //\tif this is the first pass, i\'m going to read the position from the "lastRow" image, and write a new position based on this and the hold variables\n  if (PASSINDEX == 0)\t{\n    vec4\t\tsrcPixel = IMG_PIXEL(lastRow,vec2(0.5));\n    //\ti\'m only using the X and Y components, which are the X and Y offset (normalized) for the frame\n    if (inputRate == 0.0)\t{\n      srcPixel.x = 0.0;\n      srcPixel.y = 0.0;\n    }\n    else if (inputRate <= 1.0)\t{\n      srcPixel.x = (srcPixel.x) > 0.5 ? 0.0 : 1.0;\n      srcPixel.y = 0.0;\n    }\n    else {\n      srcPixel.x = srcPixel.x + 1.0 / inputRate + srcPixel.y;\n      if (srcPixel.x > 1.0)\t{\n        srcPixel.y = mod(srcPixel.x, 1.0);\n        srcPixel.x = 0.0;\n      }\n    }\n    gl_FragColor = srcPixel;\n  }\n  if (PASSINDEX == 1)\t{\n    vec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\n    if (lastRow.x == 0.0)\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer7);\n    }\n    else\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer8);\n    }\n  }\n  else if (PASSINDEX == 2)\t{\n    vec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\n    if (lastRow.x == 0.0)\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer6);\n    }\n    else\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer7);\n    }\n  }\n  else if (PASSINDEX == 3)\t{\n    vec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\n    if (lastRow.x == 0.0)\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer5);\n    }\n    else\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer6);\n    }\n  }\n  else if (PASSINDEX == 4)\t{\n    vec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\n    if (lastRow.x == 0.0)\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer4);\n    }\n    else\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer5);\n    }\n  }\n  else if (PASSINDEX == 5)\t{\n    vec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\n    if (lastRow.x == 0.0)\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer3);\n    }\n    else\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer4);\n    }\n  }\n  else if (PASSINDEX == 6)\t{\n    vec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\n    if (lastRow.x == 0.0)\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer2);\n    }\n    else\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer3);\n    }\n  }\n  else if (PASSINDEX == 7)\t{\n    vec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\n    if (lastRow.x == 0.0)\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer1);\n    }\n    else\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer2);\n    }\n  }\n  else if (PASSINDEX == 8)\t{\n    vec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\n    if (lastRow.x == 0.0)\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(inputImage);\n    }\n    else\t{\n      gl_FragColor = IMG_THIS_NORM_PIXEL(buffer1);\n    }\n  }\n  else if (PASSINDEX == 9)\t{\n    //\tFigure out which section I\'m in and draw the appropriate buffer there\n    vec2 tex = isf_FragNormCoord;\n    vec4 color = vec4(0.0);\n    //\tfigure out the "input delay shift" for this pixel...\n    float randomDelayShift = 0.0;\n\n    vec2 xy;\n    xy.x = isf_FragNormCoord[0];\n    xy.y = isf_FragNormCoord[1];\n\n    //\tquantize the xy to the glitch_amount size\n    //xy = floor(xy / glitch_size) * glitch_size;\n    vec2 random;\n\n    float local_glitch_size = glitch_size;\n    float random_offset = 0.0;\n\n    if (randomize_size)\t{\n      random_offset = mod(rand(vec2(TIME,TIME)), 1.0);\n      local_glitch_size = random_offset * glitch_size;\n    }\n\n    if (local_glitch_size > 0.0)\t{\n      random.x = rand(vec2(floor(random_offset + xy.y / local_glitch_size) * local_glitch_size, TIME));\n      random.y = rand(vec2(floor(random_offset + xy.x / local_glitch_size) * local_glitch_size, TIME));\n    }\n    else\t{\n      random.x = rand(vec2(xy.x, TIME));\n      random.y = rand(vec2(xy.y, TIME));\n    }\n\n    //\tif doing a horizontal glitch do a random shift\n    if ((random.x < glitch_horizontal)&&(random.y < glitch_vertical))\t{\n      randomDelayShift = clamp(random.x + random.y, 0.0, 2.0);\n    }\n    else if (random.x < glitch_horizontal)\t{\n      randomDelayShift = clamp(random.x + random.y, 0.0, 2.0);\n    }\n    else if (random.y < glitch_vertical)\t{\n      randomDelayShift = clamp(random.x + random.y, 0.0, 2.0);\n    }\n\n    vec4 pixelBuffer = randomDelayShift * inputDelay * 9.0;\n\n    if (randomize_zoom)\t{\n      if ((random.x < glitch_horizontal)&&(random.y < glitch_vertical))\t{\n        float level = (random.x + random.y) / 3.0 + 0.90;\n        tex = (tex - vec2(0.5))*(1.0/level) + vec2(0.5);\n      }\n      else if (random.x < glitch_horizontal)\t{\n        float level = (random.x) / 2.0 + 0.95;\n        tex = (tex - vec2(0.5))*(1.0/level) + vec2(0.5);\n      }\n      else if (random.y < glitch_vertical)\t{\n        float level = (random.y) / 2.0 + 0.95;\n        tex = (tex - vec2(0.5))*(1.0/level) + vec2(0.5);\n      }\n    }\n\n    if (randomize_position)\t{\n      if ((random.x < glitch_horizontal)&&(random.y < glitch_vertical))\t{\n        tex.x = mod(tex.x + inputDelay.r * random.x, 1.0);\n        tex.y = mod(tex.y + inputDelay.r * random.y, 1.0);\n      }\n      else if (random.x < glitch_horizontal)\t{\n        tex.y = mod(tex.y + inputDelay.r * random.x, 1.0);\n      }\n      else if (random.y < glitch_vertical)\t{\n        tex.x = mod(tex.x + inputDelay.r * random.y, 1.0);\n      }\n      //\tapply small random zoom too\n    }\n\n    if (pixelBuffer.r < 1.0)\t{\n      color.r = IMG_NORM_PIXEL(inputImage, tex).r;\n    }\n    else if (pixelBuffer.r < 2.0)\t{\n      color.r = IMG_NORM_PIXEL(buffer1, tex).r;\n    }\n    else if (pixelBuffer.r < 3.0)\t{\n      color.r = IMG_NORM_PIXEL(buffer2, tex).r;\n    }\n    else if (pixelBuffer.r < 4.0)\t{\n      color.r = IMG_NORM_PIXEL(buffer3, tex).r;\n    }\n    else if (pixelBuffer.r < 5.0)\t{\n      color.r = IMG_NORM_PIXEL(buffer4, tex).r;\n    }\n    else if (pixelBuffer.r < 6.0)\t{\n      color.r = IMG_NORM_PIXEL(buffer5, tex).r;\n    }\n    else if (pixelBuffer.r < 7.0)\t{\n      color.r = IMG_NORM_PIXEL(buffer6, tex).r;\n    }\n    else if (pixelBuffer.r < 8.0)\t{\n      color.r = IMG_NORM_PIXEL(buffer7, tex).r;\n    }\n    else\t{\n      color.r = IMG_NORM_PIXEL(buffer8, tex).r;\n    }\n\n    if (randomize_position)\t{\n      if ((random.x < glitch_horizontal)&&(random.y < glitch_vertical))\t{\n        tex.x = mod(tex.x + random.x * inputDelay.g, 1.0);\n        tex.y = mod(tex.y + random.y * inputDelay.g, 1.0);\n      }\n      else if (random.x < glitch_horizontal)\t{\n        tex.y = mod(tex.y + random.x * inputDelay.g, 1.0);\n      }\n      else if (random.y < glitch_vertical)\t{\n        tex.x = mod(tex.x + random.y * inputDelay.g, 1.0);\n      }\n      //\tapply small random zoom too\n      //float level = inputDelay.g * random.x / 5.0 + 0.9;\n      //tex = (tex - vec2(0.5))*(1.0/level) + vec2(0.5);\n    }\n\n    if (pixelBuffer.g < 1.0)\t{\n      color.g = IMG_NORM_PIXEL(inputImage, tex).g;\n    }\n    else if (pixelBuffer.g < 2.0)\t{\n      color.g = IMG_NORM_PIXEL(buffer1, tex).g;\n    }\n    else if (pixelBuffer.g < 3.0)\t{\n      color.g = IMG_NORM_PIXEL(buffer2, tex).g;\n    }\n    else if (pixelBuffer.g < 4.0)\t{\n      color.g = IMG_NORM_PIXEL(buffer3, tex).g;\n    }\n    else if (pixelBuffer.g < 5.0)\t{\n      color.g = IMG_NORM_PIXEL(buffer4, tex).g;\n    }\n    else if (pixelBuffer.g < 6.0)\t{\n      color.g = IMG_NORM_PIXEL(buffer5, tex).g;\n    }\n    else if (pixelBuffer.g < 7.0)\t{\n      color.g = IMG_NORM_PIXEL(buffer6, tex).g;\n    }\n    else if (pixelBuffer.g < 8.0)\t{\n      color.g = IMG_NORM_PIXEL(buffer7, tex).g;\n    }\n    else\t{\n      color.g = IMG_NORM_PIXEL(buffer8, tex).g;\n    }\n\n    if (randomize_position)\t{\n      if ((random.x < glitch_horizontal)&&(random.y < glitch_vertical))\t{\n        tex.x = mod(tex.x + random.x * inputDelay.b, 1.0);\n        tex.y = mod(tex.y + random.y * inputDelay.b, 1.0);\n      }\n      else if (random.x < glitch_horizontal)\t{\n        tex.y = mod(tex.y + random.x * inputDelay.b, 1.0);\n      }\n      else if (random.y < glitch_vertical)\t{\n        tex.x = mod(tex.x + random.y * inputDelay.b, 1.0);\n      }\n      //\tapply small random zoom too\n      //float level = inputDelay.b * random.x / 5.0 + 0.9;\n      //tex = (tex - vec2(0.5))*(1.0/level) + vec2(0.5);\n    }\n\n    if (pixelBuffer.b < 1.0)\t{\n      color.b = IMG_NORM_PIXEL(inputImage, tex).b;\n    }\n    else if (pixelBuffer.b < 2.0)\t{\n      color.b = IMG_NORM_PIXEL(buffer1, tex).b;\n    }\n    else if (pixelBuffer.b < 3.0)\t{\n      color.b = IMG_NORM_PIXEL(buffer2, tex).b;\n    }\n    else if (pixelBuffer.b < 4.0)\t{\n      color.b = IMG_NORM_PIXEL(buffer3, tex).b;\n    }\n    else if (pixelBuffer.b < 5.0)\t{\n      color.b = IMG_NORM_PIXEL(buffer4, tex).b;\n    }\n    else if (pixelBuffer.b < 6.0)\t{\n      color.b = IMG_NORM_PIXEL(buffer5, tex).b;\n    }\n    else if (pixelBuffer.b < 7.0)\t{\n      color.b = IMG_NORM_PIXEL(buffer6, tex).b;\n    }\n    else if (pixelBuffer.b < 8.0)\t{\n      color.b = IMG_NORM_PIXEL(buffer7, tex).b;\n    }\n    else\t{\n      color.b = IMG_NORM_PIXEL(buffer8, tex).b;\n    }\n\n    if (randomize_position)\t{\n      if ((random.x < glitch_horizontal)&&(random.y < glitch_vertical))\t{\n        tex.x = mod(tex.x + random.x * inputDelay.a, 1.0);\n        tex.y = mod(tex.y + random.y * inputDelay.a, 1.0);\n      }\n      else if (random.x < glitch_horizontal)\t{\n        tex.y = mod(tex.y + random.x * inputDelay.a, 1.0);\n      }\n      else if (random.y < glitch_vertical)\t{\n        tex.x = mod(tex.x + random.y * inputDelay.a, 1.0);\n      }\n      //\tapply small random zoom too\n      //float level = inputDelay.a * random.x / 5.0 + 0.9;\n      //tex = (tex - vec2(0.5))*(1.0/level) + vec2(0.5);\n    }\n\n    if (pixelBuffer.a < 1.0)\t{\n      color.a = IMG_NORM_PIXEL(inputImage, tex).a;\n    }\n    else if (pixelBuffer.a < 2.0)\t{\n      color.a = IMG_NORM_PIXEL(buffer1, tex).a;\n    }\n    else if (pixelBuffer.a < 3.0)\t{\n      color.a = IMG_NORM_PIXEL(buffer2, tex).a;\n    }\n    else if (pixelBuffer.a < 4.0)\t{\n      color.a = IMG_NORM_PIXEL(buffer3, tex).a;\n    }\n    else if (pixelBuffer.a < 5.0)\t{\n      color.a = IMG_NORM_PIXEL(buffer4, tex).a;\n    }\n    else if (pixelBuffer.a < 6.0)\t{\n      color.a = IMG_NORM_PIXEL(buffer5, tex).a;\n    }\n    else if (pixelBuffer.a < 7.0)\t{\n      color.a = IMG_NORM_PIXEL(buffer6, tex).a;\n    }\n    else if (pixelBuffer.a < 8.0)\t{\n      color.a = IMG_NORM_PIXEL(buffer7, tex).a;\n    }\n    else\t{\n      color.a = IMG_NORM_PIXEL(buffer8, tex).a;\n    }\n\n    gl_FragColor = color;\n  }\n}\n'}});