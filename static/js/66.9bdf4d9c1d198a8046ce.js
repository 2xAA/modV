webpackJsonp([66],{792:function(t,n){t.exports='\n/*{\n\t"CREDIT": "by VIDVOX",\n\t"ISFVSN": "2",\n\t"CATEGORIES": [\n\t\t"Geometry Adjustment", "Glitch"\n\t],\n\t"INPUTS": [\n\t\t{\n\t\t\t"NAME": "inputImage",\n\t\t\t"TYPE": "image"\n\t\t},\n\t\t{\n\t\t\t"NAME": "seed",\n\t\t\t"TYPE": "float",\n\t\t\t"MIN": 0.01,\n\t\t\t"MAX": 1.0,\n\t\t\t"DEFAULT": 0.5\n\t\t},\n\t\t{\n\t\t\t"NAME": "cell_size",\n\t\t\t"TYPE": "float",\n\t\t\t"MIN": 0.01,\n\t\t\t"MAX": 1.0,\n\t\t\t"DEFAULT": 0.125\n\t\t},\n\t\t{\n\t\t\t"NAME": "allow_flips_h",\n\t\t\t"TYPE": "bool",\n\t\t\t"DEFAULT": 1.0\n\t\t},\n\t\t{\n\t\t\t"NAME": "allow_flips_v",\n\t\t\t"TYPE": "bool",\n\t\t\t"DEFAULT": 0.0\n\t\t}\n\t\t\n\t]\n}*/\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n// CALCULATE EDGES OF CURRENT CELL\n\t//\tAt 0.0 just do a pass-thru\n\tif (cell_size == 0.0)\t{\n\t\tgl_FragColor = IMG_THIS_PIXEL(inputImage);\n\t}\n\t\telse\t{\n\t\t// Position of current pixel\n\t\tvec2 xy; \n\t\txy.x = isf_FragNormCoord[0];\n\t\txy.y = isf_FragNormCoord[1];\n\n\n\t\t// Left and right of tile\n\t\tfloat CellWidth = cell_size;\n\t\tfloat CellHeight = cell_size;\n\t\t\n\t\t/*\n\t\tfloat x1 = floor(xy.x / CellWidth)*CellWidth;\n\t\tfloat x2 = clamp((ceil(xy.x / CellWidth)*CellWidth), 0.0, 1.0);\n\t\t// Top and bottom of tile\n\t\tfloat y1 = floor(xy.y / CellHeight)*CellHeight;\n\t\tfloat y2 = clamp((ceil(xy.y / CellHeight)*CellHeight), 0.0, 1.0);\n\t\t*/\n\t\t\n\t\t//\tdivide 1 by the cell width and cell height to determine the count\n\t\tfloat rows = floor(1.0/CellHeight);\n\t\tfloat cols = floor(1.0/CellWidth);\n\t\tfloat count = floor(rows * cols);\n\t\t\n\t\t//\tfigure out the ID # of the region\n\t\tfloat region = cols*floor(xy.x / CellWidth) + floor(xy.y / CellHeight);\n\n\t\t//\tuse this to draw the gradient of the regions as gray colors..\n\t\t//gl_FragColor = vec4(vec3(region/count),1.0);\n\t\t\n\t\t//\tnow translate this region to another random region using our seed and region\n\t\tfloat translated = clamp(rand(vec2(region/count, seed)),0.0,1.0);\n\t\t//translated = region/count;\n\t\t//gl_FragColor = vec4(vec3(translated),1.0);\n\t\t\n\t\t//\tquantize the translated!\n\t\ttranslated = floor(count * translated);\n\t\t//gl_FragColor = vec4(vec3(translated),1.0);\n\t\t//\tnow convert the translated region back to an xy location\n\t\t//\tget the relative position within the original block and then add on the translated amount\n\t\txy.x = (xy.x - floor(xy.x / CellWidth)*CellWidth) + CellWidth * floor(translated / rows);\n\t\t//xy.x = (xy.x - floor(xy.x / CellWidth)*CellWidth);\n\t\txy.y = xy.y - floor(xy.y / CellHeight)*CellHeight + CellHeight * floor(mod(translated , cols));\n\t\t\n\t\t//\tlastly if flips are allowed, randomly flip h\n\t\tif (allow_flips_h)\t{\n\t\t\tfloat flipx = rand(vec2(translated, seed));\n\t\t\tif (flipx > 0.5)\t{\n\t\t\t\txy.x = 1.0-xy.x;\n\t\t\t}\n\t\t}\n\t\tif (allow_flips_v)\t{\n\t\t\tfloat flipy = rand(vec2(translated, seed));\n\t\t\tif (flipy > 0.5)\t{\n\t\t\t\txy.y = 1.0-xy.y;\n\t\t\t}\n\t\t}\n\t\t\n\t\tgl_FragColor = IMG_NORM_PIXEL(inputImage, xy);\n\t\t\n\t}\n}'}});