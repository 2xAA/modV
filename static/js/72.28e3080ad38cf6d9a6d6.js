webpackJsonp([72],{809:function(t,n){t.exports='/*{\n  "CREDIT": "by thedantheman",\n  "DESCRIPTION": "",\n  "CATEGORIES": [\n  ],\n  "INPUTS": [\n   {\n "NAME": "inputA",\n "TYPE": "float",\n "MAX" : 10.0,\n "MIN" : 0.0,\n "DEFAULT":0.002\n },\n {\n "NAME": "inputF",\n "TYPE": "float",\n "MAX" : 10.0,\n "MIN" : 0.2,\n "DEFAULT":1.0\n },\n  {\n "NAME": "timeScale",\n "TYPE": "float",\n "MAX" : 10.0,\n "MIN" : 0.2,\n "DEFAULT":1.0\n },\n {\n "NAME": "timeOffset",\n "TYPE": "float",\n "MAX" : 1.0,\n "MIN" : 0.0,\n "DEFAULT":0.4\n },\n {\n "NAME": "slide",\n "TYPE": "point2D",\t\n "DEFAULT": [0,0],\n "MIN": [-1,-1],\n "MAX": [1,1]\n },\n {\n "NAME": "slidePos",\n "TYPE": "float",\n "MAX" : 1000.0,\n "MIN" : 0.0,\n "DEFAULT":0.0\n }\n]\n}\n*/\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n// rotate position around axis\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\n// 1D random numbers\nfloat rand1(float n)\n{\n    return fract(sin(n) * 58.5453123);\n}\n\n// 2D random numbers\nvec2 rand2(in vec2 p)\n{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077 + TIME), cos(p.x * 391.32 + p.y * 49.077 + TIME)));\n}\n\n// 1D noise\nfloat noiseF(float p)\n{\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(rand1(fl), rand1(fl + 1.0), fc);\n}\n\n// voronoi distance noise, based on iq\'s articles\nfloat voronoi(in vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\t\n\tvec2 res = vec2(8.0);\n\tfor(int j = -1; j <= 1; j ++)\n\t{\n\t\tfor(int i = -1; i <= 1; i ++)\n\t\t{\n\t\t\tvec2 b = vec2(i, j);\n\t\t\tvec2 r = vec2(b) - f + rand2(p + b);\n\t\t\t\n\t\t\t// chebyshev distance, one of many ways to do this\n\t\t\tfloat d = max(abs(r.x), abs(r.y));\n\t\t\t\n\t\t\tif(d < res.x)\n\t\t\t{\n\t\t\t\tres.y = res.x;\n\t\t\t\tres.x = d;\n\t\t\t}\n\t\t\telse if(d < res.y)\n\t\t\t{\n\t\t\t\tres.y = d;\n\t\t\t}\n\t\t}\n\t}\n\treturn res.y - res.x;\n}\n\n\n\n\nvoid main(void)\n{\n\tfloat flicker = noiseF(TIME * timeScale) * (1.0-timeOffset) + timeOffset;\n\tvec2 uv = gl_FragCoord.xy / RENDERSIZE.xy;\n\tuv = (uv - 0.5) * 2.0;\n\tvec2 suv = uv;\n\tuv.x *= RENDERSIZE.x / RENDERSIZE.y;\n\t\n\t\n\tfloat v = 0.0;\n\t\n\t// that looks highly interesting:\n\t//v = 1.0 - length(uv) * 1.3;\n\t\n\t\n\t// a bit of camera movement\n\t//uv *= 0.6 + sin(TIME * 0.1) * 0.4;\n\t//uv = rotate(uv, sin(0.0 * 0.3) * 1.0);\n\tuv += slide*slidePos;\n\t\n\t\n\t// add some noise octaves\n\tfloat a = inputA, f = inputF;\n\t\n\tfor(int i = 0; i < 3; i ++) // 4 octaves also look nice, its getting a bit slow though\n\t{\t\n\t\tfloat v1 = voronoi(uv * f + 1.0);\n\t\tfloat v2 = 0.0;\n\t\t\n\t\t// make the moving electrons-effect for higher octaves\n\t\tif(i > 0)\n\t\t{\n\t\t\t// of course everything based on voronoi\n\t\t\tv2 = voronoi(uv * f * 0.5 + 50.0 + TIME);\n\t\t\t\n\t\t\tfloat va = 0.0, vb = 0.0;\n\t\t\tva = 1.0 - smoothstep(0.0, 0.1, v1);\n\t\t\tvb = 1.0 - smoothstep(0.0, 0.08, v2);\n\t\t\tv += a * pow(va * (0.5 + vb), 2.0);\n\t\t}\n\t\t\n\t\t// make sharp edges\n\t\tv1 = 1.0 - smoothstep(0.0, 0.3, v1);\n\t\t\n\t\t// noise is used as intensity map\n\t\tv2 = a * (noiseF(v1 * 10.0 + 0.1));\n\t\t\n\t\t// octave 0\'s intensity changes a bit\n\t\tif(i == 0)\n\t\t\tv += v2*flicker;\n\t\telse\n\t\t\tv += v2;\n\t\t\n\t\tf *= inputF;\n\t\ta *= inputA;\n\t}\n\n\t// slight vignetting\n\tv *= exp(-0.6 * length(suv)) * 1.2;\n\t\n\t// use texture channel0 for color? why not.\n\t//vec3 cexp = IMG_NORM_PIXEL(iChannel0,uv * 0.001).xyz * 3.0 + IMG_NORM_PIXEL(iChannel0,uv * 0.01).xyz;//vec3(1.0, 2.0, 4.0);\n\t\n\t// old blueish color set\n\tvec3 cexp = vec3(3.0, 2.0, 4.0);\n\t\tcexp *= 1.3;\n\n\tvec3 col = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 1.0;\n\t\n\tgl_FragColor = vec4(col, 1.0);\n}'}});