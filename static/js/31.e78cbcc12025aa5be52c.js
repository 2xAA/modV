webpackJsonp([31],{821:function(e,n){e.exports='\n/*{\n  "CREDIT": "by VIDVOX",\n  "CATEGORIES": [\n    "Stylize"\n  ],\n  "INPUTS": [\n    {\n      "NAME": "inputImage",\n      "TYPE": "image"\n    },\n    {\n      "NAME": "cell_size",\n      "TYPE": "float",\n      "MIN": 0.001,\n      "MAX": 0.5,\n      "DEFAULT": 0.125\n    },\n    {\n      "NAME": "style",\n      "VALUES": [\n        0,\n        1\n      ],\n      "LABELS": [\n        "Squared",\n        "Diamond"\n      ],\n      "DEFAULT": 1,\n      "TYPE": "long"\n    }\n  ]\n}*/\n\n\n\nvoid main()\n{\n// CALCULATE EDGES OF CURRENT CELL\n  //  At 0.0 just do a pass-thru\n  if (cell_size == 0.0) {\n    gl_FragColor = IMG_THIS_PIXEL(inputImage);\n  }\n  else  {\n    // Position of current pixel\n    vec2 xy;\n    xy.x = isf_FragNormCoord[0];\n    xy.y = isf_FragNormCoord[1];\n\n\n    // Left and right of tile\n    float CellWidth = cell_size;\n    float CellHeight = cell_size;\n\n    CellHeight = cell_size * RENDERSIZE.x / RENDERSIZE.y;\n\n    float x1 = floor(xy.x / CellWidth)*CellWidth;\n    float x2 = clamp((ceil(xy.x / CellWidth)*CellWidth), 0.0, 1.0);\n    // Top and bottom of tile\n    float y1 = floor(xy.y / CellHeight)*CellHeight;\n    float y2 = clamp((ceil(xy.y / CellHeight)*CellHeight), 0.0, 1.0);\n\n    //  get the normalized local coords in the cell\n    float x = (xy.x-x1) / CellWidth;\n    float y = (xy.y-y1) / CellHeight;\n    vec4 avgClr = vec4(0.0);\n\n    //  style 0, two right triangles making a square\n    if (style == 0) {\n      //  if above the center line...\n      if (x < y)  {\n        // Average bottom left, top left, center and top right pixels\n        vec4 avgL = (IMG_NORM_PIXEL(inputImage, vec2(x1, y1))+(IMG_NORM_PIXEL(inputImage, vec2(x1, y2)))) / 2.0;\n        vec4 avgR = IMG_NORM_PIXEL(inputImage, vec2(x2, y2));\n        vec4 avgC = IMG_NORM_PIXEL(inputImage, vec2(x1+(CellWidth/2.0), y2+(CellHeight/2.0)));  // Average the averages + centre\n        avgClr = (avgL+avgR+avgC) / 3.0;\n      }\n      else  {\n        // Average bottom right, bottom left, center and top right pixels\n        vec4 avgR = (IMG_NORM_PIXEL(inputImage, vec2(x2, y1))+(IMG_NORM_PIXEL(inputImage, vec2(x2, y2)))) / 2.0;\n        vec4 avgL = IMG_NORM_PIXEL(inputImage, vec2(x1, y1));\n        vec4 avgC = IMG_NORM_PIXEL(inputImage, vec2(x1+(CellWidth/2.0), y2+(CellHeight/2.0)));  // Average the averages + centre\n        avgClr = (avgL+avgR+avgC) / 3.0;\n      }\n    }\n    //  style 1, four triangles making a square\n    else {\n      //  if above the B2T center line and below the T2B center line...\n      if ((x > y)&&(x < 1.0 - y)) {\n        // Average bottom left, bottom right, center\n        vec4 avgL = IMG_NORM_PIXEL(inputImage, vec2(x1, y1));\n        vec4 avgR = IMG_NORM_PIXEL(inputImage, vec2(x2, y1));\n        vec4 avgC = IMG_NORM_PIXEL(inputImage, vec2(x1+(CellWidth/2.0), y2+(CellHeight/2.0)));  // Average the averages + centre\n        avgClr = (avgL+avgR+avgC) / 3.0;\n      }\n      else if ((x < y)&&(x < 1.0 - y))  {\n        // Average bottom left, top left, center\n        vec4 avgL = IMG_NORM_PIXEL(inputImage, vec2(x1, y1));\n        vec4 avgR = IMG_NORM_PIXEL(inputImage, vec2(x1, y2));\n        vec4 avgC = IMG_NORM_PIXEL(inputImage, vec2(x1+(CellWidth/2.0), y2+(CellHeight/2.0)));  // Average the averages + centre\n        avgClr = (avgL+avgR+avgC) / 3.0;\n      }\n      else if ((x > 1.0 - y)&&(x < y))  {\n        // Average top left, top right, center\n        vec4 avgL = IMG_NORM_PIXEL(inputImage, vec2(x1, y2));\n        vec4 avgR = IMG_NORM_PIXEL(inputImage, vec2(x2, y2));\n        vec4 avgC = IMG_NORM_PIXEL(inputImage, vec2(x1+(CellWidth/2.0), y2+(CellHeight/2.0)));  // Average the averages + centre\n        avgClr = (avgL+avgR+avgC) / 3.0;\n        //avgClr = vec4(0.0,1.0,0.0,1.0);\n      }\n      else  {\n        // Average top right, bottom right, center\n        vec4 avgL = IMG_NORM_PIXEL(inputImage, vec2(x2, y1));\n        vec4 avgR = IMG_NORM_PIXEL(inputImage, vec2(x2, y2));\n        vec4 avgC = IMG_NORM_PIXEL(inputImage, vec2(x1+(CellWidth/2.0), y2+(CellHeight/2.0)));  // Average the averages + centre\n        avgClr = (avgL+avgR+avgC) / 3.0;\n        //avgClr = vec4(0.0,0.0,1.0,1.0);\n      }\n    }\n\n    gl_FragColor = avgClr;\n  }\n}\n'}});