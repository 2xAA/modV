webpackJsonp([53],{824:function(n,a){n.exports='/*{\n  "CREDIT": "by You",\n  "DESCRIPTION": "",\n  "CATEGORIES": [\n  ],\n  "INPUTS": [\n    {\n      "NAME": "SCALE",\n      "TYPE": "float",\n      "MIN": -10,\n      "MAX": 10,\n      "DEFAULT": -2\n\n    },\n    {\n      "NAME": "dthresh",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX":5\n    },{\n      "NAME": "fixedRad2",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX":10,\n      "DEFAULT": 2\n\n    },  {\n      "NAME": "foldingLimit",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX":10,\n      "DEFAULT": 1\n    },\n    {\n      "NAME": "minRad2",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX":2\n    },\n    {\n      "NAME": "dhue",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX":3.14\n    },\n    {\n      "NAME": "speed",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX":2000\n    },\n    {\n      "NAME": "rotation",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX":100\n    },\n  {\n      "NAME": "e0",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 20,\n      "DEFAULT": 3\n\n    },\n      {\n      "NAME": "x",\n      "TYPE": "float",\n      "MIN": -1,\n      "MAX": 1,\n      "DEFAULT": 1\n\n    },\n      {\n      "NAME": "y",\n      "TYPE": "float",\n      "MIN": -1,\n      "MAX": 1\n    },\n      {\n      "NAME": "z",\n      "TYPE": "float",\n      "MIN": -1,\n      "MAX": 1\n    },\n          {\n      "NAME": "type",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 1\n    }\n  ]\n}*/\n\n#define MAX_ITER 35\n\n#define MAX_ORBIT 10\n\nfloat THRESH =  1. / exp(dthresh);\nvec4 scale = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / minRad2;\n\n\n// greetz 2 Mikael Hvidtfeldt Christensen\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n\n\nvoid sphereFold(inout vec3 z, inout float dz) {\n\n  float fixedRadius2 = fixedRad2;\n  float minRadius2  = minRad2;\n\n  float r2 = dot(z,z);\n  if (r2 < minRadius2) {\n    // linear inner scaling\n    float temp = (fixedRadius2/minRadius2);\n    z *= temp;\n    dz*= temp;\n  } else if (r2 < fixedRadius2) {\n    // this is the actual sphere inversion\n    float temp =(fixedRadius2/r2);\n    z *= temp;\n    dz*= temp;\n  }\n}\n\nvoid boxFold(inout vec3 z, inout float dz) {\n  float foldingLimit = foldingLimit;\n  z = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\n\nvec2 DE(vec3 z)\n{\n  vec3 offset = z;\n  float dr = 1.0;\n\n  float Scale = SCALE;\n  float iter = 0.0;\n\n  for (int n = 0; n < MAX_ORBIT; n++) {\n    boxFold(z,dr);       // Reflect\n    sphereFold(z,dr);    // Sphere Inversion\n\n        z=Scale*z + offset;  // Scale & Translate\n        dr = dr*abs(Scale)+1.0;\n        iter++;\n        if (abs(dr) > 1000000.)\n          break;\n  }\n  float r = length(z);\n\n  return vec2(iter, r/abs(dr));\n}\n\n\n//----------------------------------------------------------------------------------------\nfloat Map(vec3 pos)\n{\n\n  if ( type == 0.0 )\n    return DE(pos).y;\n\n  vec4 p = vec4(pos,1);\n  vec4 p0 = p;  // p.w is the distance estimate\n\n  for (int i = 0; i < 11; i++)\n  {\n    p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n\n    // sphere folding:\n    float r2 = dot(p.xyz, p.xyz);\n\n    //if (r2 < minRad2) p /= minRad2; else if (r2 < 1.0) p /= r2;\n    p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n\n    // scale, translate\n    p = p*scale + p0;\n  }\n\n  return ((length(p.xyz) - abs(SCALE) + 1.0) / p.w);\n}\n\nvec3 hsv(in float h, in float s, in float v) {\n  return mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 CameraPath( float t )\n{\n    vec3 p = vec3(-.81 + 3. * sin(2.14*t),.05+2.5 * sin(.942*t+1.3),.05 + 3.5 * cos(3.594*t) );\n  return p * e0;\n}\n\nmat3 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 zaxis = normalize(center - eye);\n    vec3 xaxis = normalize(cross(up, zaxis));\n    vec3 yaxis = cross(zaxis, xaxis);\n\n    mat3 matrix;\n    //Column Major\n    matrix[0][0] = xaxis.x;\n    matrix[1][0] = yaxis.x;\n    matrix[2][0] = zaxis.x;\n\n    matrix[0][1] = xaxis.y;\n    matrix[1][1] = yaxis.y;\n    matrix[2][1] = zaxis.y;\n\n    matrix[0][2] = xaxis.z;\n    matrix[1][2] = yaxis.z;\n    matrix[2][2] = zaxis.z;\n\n    return matrix;\n}\n\nvoid main() {\n\n  vec2 xy = gl_FragCoord.xy / RENDERSIZE - 0.5;\n  float aspect = RENDERSIZE.x / RENDERSIZE.y;\n  xy = vec2(aspect, 1.0) * xy * 2.;\n\n\n  float t = 0.;\n  vec3 p;\n  float t_cam = TIME/speed;\n\n\n  vec3 camPos = CameraPath(t_cam);\n  if ( speed == 0.0 )\n    camPos = vec3(x,y,z) * e0;\n\n  vec3 forward = CameraPath(t_cam + 0.1) - camPos;\n\n  vec3 ray = normalize(vec3(xy, 1.0));\n  //mat3 rot_cam = RotationMatrix(vec3(1., 1., 0.), t_cam);\n  mat3 rot_cam = lookAt(normalize(camPos), vec3(0.0,0.0,0.0), vec3(0.0,1.0, 0.0));\n\n\n  ray = rot_cam * ray;\n\n  // if(rotation < 4.)\n    //    ray = RotationMatrix(vec3(0.,0.,1.), rotation * length(xy)) * ray;\n  // else\n    //    ray = RotationMatrix(vec3(sin(TIME/speed/10. + 3.),sin(TIME/speed/20.),1.), sin(rotation * TIME/speed) ) * ray;\n\n  float iter = 0.;\n  bool hit = false;\n    float last_t = 0.;\n\n  for (int i = 0; i < MAX_ITER; i++) {\n    p = t * ray + camPos;\n    float d = Map(p);\n    float thr = exp ( t * dthresh)/ pow(10.0, 3.4) ;\n    if (d < thr){\n\n      hit = true;\n      break;\n    }\n    last_t = t;\n    t += d ;//max(thr, d);\n    iter++;\n  }\n\n\n  float d = 1.0 - iter / float(MAX_ITER);\n\n  vec3 color = hsv(d/3. + dhue,1.,d);\n\n    if(dhue == 0.0)\n    color = vec3(d);\n\n  //color = hsv(t/4.,1.,1. - t/4.);\n\n  gl_FragColor = vec4(color, 1.0);\n}'}});