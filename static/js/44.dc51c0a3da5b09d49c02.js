webpackJsonp([44],{810:function(n,o){n.exports='//\tadapted from https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/GodRaysPass.cpp\n\n\n/*{\n  "DESCRIPTION": "",\n  "CREDIT": "by VIDVOX",\n  "CATEGORIES": [\n    "Stylize"\n  ],\n  "INPUTS": [\n    {\n      "NAME": "inputImage",\n      "TYPE": "image"\n    },\n    {\n      "NAME": "intensity",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 10,\n      "DEFAULT": 5\n    },\n    {\n      "NAME": "gain",\n      "TYPE": "float",\n      "MIN": 0,\n      "MAX": 1,\n      "DEFAULT": 1\n    },\n    {\n      "NAME": "neonColor",\n      "TYPE": "color",\n      "DEFAULT": [\n        1,\n        0.4,\n        0.64,\n        1\n      ]\n    }\n  ]\n}*/\n\n\nvarying vec2 left_coord;\nvarying vec2 right_coord;\nvarying vec2 above_coord;\nvarying vec2 below_coord;\n\nvarying vec2 lefta_coord;\nvarying vec2 righta_coord;\nvarying vec2 leftb_coord;\nvarying vec2 rightb_coord;\n\n\nfloat gray(vec4 n)\n{\n\treturn (n.r + n.g + n.b)/3.0;\n}\n\n\nvoid main(void)\n{\n\n\t//\tedges // rays // color\n\tvec4 color = IMG_THIS_PIXEL(inputImage);\n\tvec4 colorL = IMG_NORM_PIXEL(inputImage, left_coord);\n\tvec4 colorR = IMG_NORM_PIXEL(inputImage, right_coord);\n\tvec4 colorA = IMG_NORM_PIXEL(inputImage, above_coord);\n\tvec4 colorB = IMG_NORM_PIXEL(inputImage, below_coord);\n\n\tvec4 colorLA = IMG_NORM_PIXEL(inputImage, lefta_coord);\n\tvec4 colorRA = IMG_NORM_PIXEL(inputImage, righta_coord);\n\tvec4 colorLB = IMG_NORM_PIXEL(inputImage, leftb_coord);\n\tvec4 colorRB = IMG_NORM_PIXEL(inputImage, rightb_coord);\n\n\tfloat gx = (0.0);\n\tfloat gy = (0.0);\n\tgx = (-1.0 * gray(colorLA)) + (-1.0 * gray(colorL)) + (-1.0 * gray(colorLB)) + (1.0 * gray(colorRA)) + (1.0 * gray(colorR)) + (1.0 * gray(colorRB));\n\tgy = (1.0 * gray(colorLA)) + (1.0 * gray(colorA)) + (1.0 * gray(colorRA)) + (-1.0 * gray(colorRB)) + (-1.0 * gray(colorB)) + (-1.0 * gray(colorLB));\n\n\n\n\tfloat bright = pow(gx*gx + gy*gy,0.5);\n\tvec4 final = color * bright;\n\t\n\t//\tif the brightness is below the threshold draw black\n\tif (bright < 0.01)\t{\n\t\tfinal = vec4(0.0);\n\t}\n\telse\t{\n\t\tfinal = final * intensity;\n\t}\n\t\n\tgl_FragColor = final;\n\n\tvec4 origColor = final;\n\tvec4 raysColor = color;\n\tint NUM_SAMPLES = 30;\n\n\tfloat exposure\t= 0.1/float(NUM_SAMPLES);\n\tfloat decay\t\t= 1.0 ;\n\tfloat density\t= 0.5;\n\tfloat weight\t= 6.0;\n\tfloat illuminationDecay = 1.0;\n\tvec2\t\tnormSrcCoord;\n\n\tnormSrcCoord.x = isf_FragNormCoord[0];\n\tnormSrcCoord.y = isf_FragNormCoord[1];\n\n\tvec2 deltaTextCoord = vec2(normSrcCoord.st - 0.5);\n\tvec2 textCoo = normSrcCoord;\n\tdeltaTextCoord *= 1.0 / float(NUM_SAMPLES) * density;\n\n\tfor(float i=0.0; i < 30.0 ; i++)\t{\n\t\ttextCoo -= deltaTextCoord;\n\t\tvec4 tsample = IMG_NORM_PIXEL(inputImage, textCoo);\n\t\ttsample *= illuminationDecay * weight;\n\t\traysColor += tsample;\n\t\tilluminationDecay *= decay;\n\t}\n\traysColor *= exposure * gain;\n\tfloat p = 0.3 *raysColor.g + 0.59*raysColor.r + 0.11*raysColor.b;\n\t\n\tgl_FragColor = gray(origColor + p) * neonColor;\n\t\n}'}});