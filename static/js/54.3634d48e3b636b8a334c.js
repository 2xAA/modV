webpackJsonp([54],{800:function(n,e){n.exports='/*{\n  "CREDIT": "by mojovideotech",\n  "CATEGORIES": [\n    "Automatically Converted"\n  ],\n  "DESCRIPTION": "",\n  "INPUTS": [\n    {\n      "MAX": [\n        1,\n        1\n      ],\n      "MIN": [\n        0,\n        0\n      ],\n      "DEFAULT": [\n        0.5,\n        0.5\n      ],\n      "NAME": "center",\n      "TYPE": "point2D"\n    },\n    {\n      "MAX": [\n        10,\n        10\n      ],\n      "MIN": [\n        0.5,\n        0.5\n      ],\n      "DEFAULT": [\n        2,\n        2.25\n      ],\n      "NAME": "shape",\n      "TYPE": "point2D"\n    },\n    {\n      "NAME": "speed",\n      "TYPE": "float",\n      "DEFAULT": 0.5,\n      "MIN": 0.0001,\n      "MAX": 1\n    },\n    {\n      "NAME": "rotation",\n      "TYPE": "float",\n      "DEFAULT": 0.05,\n      "MIN": 0.005,\n      "MAX": 0.5\n    },\n    {\n      "NAME": "R",\n      "TYPE": "float",\n      "DEFAULT": 0.05,\n      "MIN": 0,\n      "MAX": 0.5\n    },\n    {\n      "NAME": "G",\n      "TYPE": "float",\n      "DEFAULT": 0.125,\n      "MIN": 0,\n      "MAX": 0.5\n    },\n    {\n      "NAME": "B",\n      "TYPE": "float",\n      "DEFAULT": 0.25,\n      "MIN": 0,\n      "MAX": 0.5\n    }\n  ]\n}*/\n\n\n///////////////////////////////////////////\n// HexVortex  by mojovideotech\n//\n// based on:\n// glslsandbox.com/\\e#4671.0\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n///////////////////////////////////////////\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n#define   pi    3.141592653589793   // pi\n#define   e       2.718281828459045   // eulers number\n#define   prphi 2.028876065463213 // pi root of phi\n#define   sqpi  1.772453850905516 // square root of pi\n#define   thpi    0.996272076220750 // tanh(pi)\n#define   lgpi    0.497149872694134   // log(pi)\n#define   rcpi    0.318309886183791 // reciprocal of pi  , 1/pi\n\n\nvec3 rotXY(vec3 p, vec2 rad) {\n  vec2 s = sin(rad);\n  vec2 c = cos(rad);\n  mat3 m = mat3(c.y, 0.0, -s.y,\n    -s.x * s.y, c.x, -s.x * c.y,\n    c.x * s.y, s.x, c.x * c.y);\n  return m * p;\n}\n\nvec2 repeat(vec2 p, float n) {\n  vec2 np = p * n;\n  vec2 npfrct = fract(np);\n  vec2 npreal = np - npfrct;\n  np.x += fract(npreal.y * lgpi);\n  return fract(np) * prphi - 1.0;\n}\n\nfloat hexDistance(vec2 ip) {\n  const float SQRT3 = sqpi;\n  vec2 TRIG30 = vec2 (sin(rcpi), cos(thpi));\n  vec2 p = abs(ip * vec2(SQRT3 * shape.x, shape.y));\n  float d = dot(p, vec2(-TRIG30.x, TRIG30.y)) - SQRT3 * 0.25;\n  return (d > 0.0)? min(d, (SQRT3 * 0.5 - p.x)) : min(-d, p.x);\n}\n\nfloat smoothEdge(float edge, float margin, float x) {\n  return smoothstep(edge - margin, edge + margin, x);\n}\n\nvoid main(void) {\n  float T = TIME * speed;\n  vec3 rgb;\n  vec2 nsc = (gl_FragCoord.xy - RENDERSIZE * 0.5) / RENDERSIZE.yy * e;\n  vec3 dir = normalize(vec3(nsc, -2.0));\n  dir = rotXY(dir, vec2((center.yx - 0.5) * pi * 0.25));\n  vec2 uv = vec2(atan(dir.y, dir.x) / (pi * 2.0) + 0.5, dir.z / length(dir.xy));\n  vec2 pos = uv * vec2(1.0, 0.2) - vec2(T * rotation, T * 0.5);\n  vec2 p = repeat(pos, 16.0);\n  float d = hexDistance(p);\n  float dist = dir.z/length(dir.xy);\n  d/=-dist;\n  float fade = 1.0 / pow(1.0 / length(dir.xy) * 0.3, 1.0);\n  fade = clamp(fade, 0.0, 1.0);\n  rgb  = mix(vec3(1.0)*fade, vec3(R,G,B), smoothEdge(0.03, 0.1, d));\n\n  gl_FragColor = vec4(rgb, 1.0);\n}'}});